<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>OpenAI Realtime (WebRTC) - Toggle & Transcript & Save</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    * { box-sizing: border-box; }
    body { margin: 0; display: grid; grid-template-columns: 1fr 420px; grid-template-rows: auto 1fr; height: 100vh; }
    header { grid-column: 1 / -1; padding: 10px 16px; background: #111827; color: #e5e7eb; display: flex; gap: 12px; align-items: center; }
    main { padding: 16px; overflow: auto; }
    aside { border-left: 1px solid #e5e7eb; display: grid; grid-template-rows: auto 1fr auto; min-width: 320px; }
    .controls { display: flex; gap: 8px; align-items: center; }
    button { padding: 8px 14px; font-size: 14px; cursor: pointer; border: 1px solid #ddd; border-radius: 8px; background: #fff; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    .status { margin-left: auto; opacity: .9; font-size: 14px; }
    .panel-title { padding: 10px 12px; font-weight: 600; border-bottom: 1px solid #eee; background: #f8fafc; }
    .log-wrap { position: relative; }
    .log { overflow: auto; padding: 12px; background: #fafafa; border-top: 1px solid #eee; border-bottom: 1px solid #eee; height: 100%; }
    .msg { margin: 10px 0; border-radius: 8px; padding: 8px 10px; background: #fff; border: 1px solid #eee; }
    .role { font-weight: 700; font-size: 12px; opacity: .75; margin-bottom: 4px; }
    .user .role { color: #2563eb; }
    .assistant .role { color: #059669; }
    .event .role { color: #6b7280; }
    .text { white-space: pre-wrap; word-break: break-word; }
    .footer { padding: 10px; display: flex; gap: 8px; justify-content: space-between; align-items: center; }
    .hint { font-size: 12px; color: #6b7280; }
  </style>
</head>
<body>
  <header>
    <div class="controls">
      <button id="toggle">â–¶ Start</button>
      <button id="clear" title="ãƒ­ã‚°ã‚’æ¶ˆå»">ğŸ§¹ Clear</button>
      <button id="export" title="JSONã§ä¿å­˜">ğŸ’¾ Export JSON</button>
    </div>
    <div class="status" id="status">Idle</div>
  </header>

  <main>
    <h2>Realtime Voice Demo</h2>
    <p>
      ã€Œâ–¶ Startã€ã§ä¼šè©±é–‹å§‹ï¼ã€Œâ–  Stopã€ã§åœæ­¢ã€‚<br/>
      å³å´ã«ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã®è¿”ç­”ãŒ <b>å­—å¹•ã¨ã—ã¦ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è¡¨ç¤º</b> ã•ã‚Œã€ç¢ºå®šå¾Œã¯ãƒ­ã‚°ã«ä¿å­˜ã•ã‚Œã¾ã™ã€‚
    </p>
    <ul>
      <li>ãƒ­ã‚°ã¯ <code>localStorage</code> ã«è‡ªå‹•ä¿å­˜ï¼ˆãƒªãƒ­ãƒ¼ãƒ‰ã—ã¦ã‚‚æ®‹ã‚Šã¾ã™ï¼‰</li>
      <li>ã€ŒExport JSONã€ã§ä¼šè©±å±¥æ­´ã‚’æ›¸ãå‡ºã—</li>
      <li>ãƒ¦ãƒ¼ã‚¶ãƒ¼å­—å¹•ã¯ç¾æ™‚ç‚¹ã§ã¯ã‚ªãƒ•ï¼ˆå¾Œã‹ã‚‰è¿½åŠ å¯èƒ½ï¼‰</li>
    </ul>
  </main>

  <aside>
    <div class="panel-title">Transcript / Logs</div>

    <div class="log-wrap">
      <div class="log" id="log"></div>

      <!-- ãƒ©ã‚¤ãƒ–å­—å¹•ï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼‰ -->
      <div class="msg user" id="live-user" style="padding:12px; display:none; position: sticky; bottom: 48px; margin:0; border-bottom-left-radius:0; border-bottom-right-radius:0; border-color:#bfdbfe; background:#eff6ff;">
        <div class="role">USER <small>speaking...</small></div>
        <div class="text" id="live-user-text"></div>
      </div>

      <!-- ãƒ©ã‚¤ãƒ–å­—å¹•ï¼ˆã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆï¼‰ -->
      <div class="msg assistant" id="live-assistant" style="padding:12px; display:none; position: sticky; bottom: 0; margin:0; border-top-left-radius: 0; border-top-right-radius:0; border-color:#d1fae5; background:#ecfdf5;">
        <div class="role">ASSISTANT <small>typing...</small></div>
        <div class="text" id="live-assistant-text"></div>
      </div>
    </div>

    <div class="footer">
      <small class="hint">Autosave: localStorage</small>
      <small id="ice" class="hint"></small>
    </div>
  </aside>

  <script>
    // ========= DOM =========
    const btn = document.getElementById("toggle");
    const btnClear = document.getElementById("clear");
    const btnExport = document.getElementById("export");
    const statusEl = document.getElementById("status");
    const iceEl = document.getElementById("ice");
    const logEl = document.getElementById("log");
    const liveRow = document.getElementById("live-assistant");
    const liveTextEl = document.getElementById("live-assistant-text");
    // è¿½åŠ ï¼šãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ©ã‚¤ãƒ–å­—å¹•DOM
    const liveUserRow = document.getElementById("live-user");
    const liveUserTextEl = document.getElementById("live-user-text");

    // ========= ä¼šè©±ãƒ­ã‚°ï¼ˆlocalStorageé€£æºï¼‰ =========
    let conversation = []; // { role: "user"|"assistant"|"system"|"event", text, ts }

    function nowIso() { return new Date().toISOString(); }
    function escapeHtml(s) { return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

    function saveLocal() {
      try { localStorage.setItem("realtime_conversation", JSON.stringify(conversation)); } catch {}
    }
    function loadLocal() {
      try {
        const raw = localStorage.getItem("realtime_conversation");
        if (raw) { conversation = JSON.parse(raw); renderLog(); }
      } catch {}
    }
    function clearLog() {
      conversation = [];
      saveLocal();
      renderLog();
    }
    function addMessage(role, text) {
      if (!text) return;
      conversation.push({ role, text, ts: nowIso() });
      renderLog();
      saveLocal();
    }
    function renderLog() {
      logEl.innerHTML = "";
      for (const m of conversation) {
        const div = document.createElement("div");
        div.className = `msg ${m.role}`;
        div.innerHTML = `
          <div class="role">${m.role.toUpperCase()} <small>${m.ts}</small></div>
          <div class="text">${escapeHtml(m.text)}</div>
        `;
        logEl.appendChild(div);
      }
      logEl.scrollTop = logEl.scrollHeight;
    }
    loadLocal();

    // ========= æ¥ç¶šåˆ¶å¾¡ =========
    let pc = null, dc = null, micStream = null, remoteAudio = null;
    let running = false, cleaning = false;

    // ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆ/ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ç¾åœ¨ç™ºè©±ï¼ˆdelta ã‚’çµåˆï¼‰
    let currentAssistantText = "";
    let currentUserText = "";

    function setStatus(t) { statusEl.textContent = t; }
    function setRunningState(on) {
      running = on;
      btn.textContent = on ? "â–  Stop" : "â–¶ Start";
      setStatus(on ? "Connected" : "Idle");
      if (!on) { iceEl.textContent = ""; }
    }

    async function fetchEphemeralSession() {
      const r = await fetch("/token", { method: "POST" });
      if (!r.ok) throw new Error(await r.text());
      return r.json(); // { client_secret: { value }, ... }
    }

    async function startSession() {
      if (running) return;
      setStatus("Starting...");
      btn.disabled = true;
      try {
        // 1) ãƒã‚¤ã‚¯
        micStream = await navigator.mediaDevices.getUserMedia({ audio: true });

        // 2) Ephemeral token
        const session = await fetchEphemeralSession();

        // 3) PeerConnection
        pc = new RTCPeerConnection();
        micStream.getTracks().forEach(t => pc.addTrack(t, micStream));

        // 4) å—ä¿¡éŸ³å£°
        pc.ontrack = (e) => {
          if (remoteAudio) {
            try { remoteAudio.pause(); } catch {}
            remoteAudio.remove();
          }
          remoteAudio = document.createElement("audio");
          remoteAudio.autoplay = true;
          remoteAudio.srcObject = e.streams[0];
          document.body.appendChild(remoteAudio);
        };

        // 5) DataChannelï¼ˆãƒ­ã‚°ãƒ»å­—å¹•å‡¦ç†ã®è¦ï¼‰
        //    - ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§ä½œæˆ
        //    - ä¸‡ä¸€ã‚µãƒ¼ãƒå´ãŒä½œæˆã—ãŸå ´åˆã«ã‚‚æ‹¾ãˆã‚‹ã‚ˆã† ondatachannel ã‚‚è¨­å®š
        const attachDataChannel = (channel) => {
          dc = channel;
          dc.onopen = () => {
            addMessage("event", "Session started");
            // åˆæœŸã‚·ã‚¹ãƒ†ãƒ æŒ‡ç¤º
            dc.send(JSON.stringify({
              type: "response.create",
              response: {
                instructions: "ã‚ãªãŸã¯è¦ªåˆ‡ãªéŸ³å£°ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã€‚ç°¡æ½”ãªæ—¥æœ¬èªã§è¦ç‚¹ã‚’è¿”ç­”ã—ã¦ãã ã•ã„ã€‚",
                modalities: ["text", "audio"]
              }
            }));
            // åˆå›èµ·å‹•ç”¨ã®çŸ­ã„ãƒ†ã‚­ã‚¹ãƒˆå…¥åŠ›ã§å¿œç­”ã‚’ç¢ºå®Ÿã«ç™ºç«
            dc.send(JSON.stringify({
              type: "response.create",
              response: {
                input_text: "ãƒ†ã‚¹ãƒˆã§ã™ã€‚çŸ­ãè‡ªå·±ç´¹ä»‹ã—ã¦ã¿ã¦ãã ã•ã„ã€‚",
                modalities: ["text", "audio"]
              }
            }));
          };

          // ---- ãƒ‡ãƒãƒƒã‚°: æœ€åˆã®æ•°ä»¶ã ã‘ç”Ÿã‚¤ãƒ™ãƒ³ãƒˆã‚’è¦³å¯Ÿ ----
          let debugCount = 0;
          const DEBUG_LIMIT = 10;

          // ---- ã“ã“ã§è¤‡æ•°ãƒ‘ã‚¿ãƒ¼ãƒ³ã®ã‚¤ãƒ™ãƒ³ãƒˆåã‚’å¸åã—ã¦å­—å¹•ã«åæ˜  ----
          dc.onmessage = (ev) => {
            try {
              const e = JSON.parse(ev.data);

              // ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›ï¼ˆæœ€åˆã®Nä»¶ã®ã¿ï¼‰
              if (debugCount < DEBUG_LIMIT) {
                console.log("[Realtime event]", e);
                debugCount++;
                if (debugCount === DEBUG_LIMIT) {
                  console.log(`(debug) reached first ${DEBUG_LIMIT} events, debug logging stopped.`);
                }
              }

              // ========== ã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆã®ã‚¹ãƒˆãƒªãƒ¼ãƒŸãƒ³ã‚°å­—å¹•ï¼ˆdeltaï¼‰ ==========
              let deltaText = "";

              // 1) æ—§: response.deltaï¼ˆstringç›´ï¼‰
              if (e.type === "response.delta" && typeof e.delta === "string") {
                deltaText = e.delta;
              }

              // 2) ã‚ˆãã‚ã‚‹: response.text.delta
              if (e.type === "response.text.delta" && typeof e.delta === "string") {
                deltaText = e.delta;
              }

              // 3) æ–°ç³»: response.output_text.delta
              if (e.type === "response.output_text.delta" && typeof e.delta === "string") {
                deltaText = e.delta;
              }

              // 3.5) éŸ³å£°ã®æ–‡å­—èµ·ã“ã—: response.audio_transcript.delta
              if (e.type === "response.audio_transcript.delta" && typeof e.delta === "string") {
                deltaText = e.delta;
              }

              // 4) äº’æ›: e.delta?.text ãªã©ã«å‚™ãˆã‚‹ï¼ˆå¿µã®ãŸã‚ï¼‰
              if (!deltaText && e && typeof e === "object" && e.delta && typeof e.delta.text === "string") {
                deltaText = e.delta.text;
              }

              // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã®å­—å¹•ã¯å‡ºã•ãšã€å®Œäº†æ™‚ã«ã¾ã¨ã‚ã¦è¡¨ç¤º
              if (deltaText) {
                currentAssistantText += deltaText;
              }

              // ========== ãƒ¦ãƒ¼ã‚¶ãƒ¼éŸ³å£°ã®æ–‡å­—èµ·ã“ã—ï¼ˆdeltaï¼‰ ==========
              let userDelta = "";

              // æ–°: conversation.item.input_audio_transcription.delta
              if (e.type === "conversation.item.input_audio_transcription.delta" && typeof e.delta === "string") {
                userDelta = e.delta;
              }

              // æ—§äº’æ›: input_audio_buffer.transcript.delta
              if (!userDelta && e.type === "input_audio_buffer.transcript.delta" && typeof e.delta === "string") {
                userDelta = e.delta;
              }

              if (userDelta) {
                currentUserText += userDelta;
                // ãƒ©ã‚¤ãƒ–è¡¨ç¤ºï¼ˆãƒ¦ãƒ¼ã‚¶ãƒ¼ï¼‰
                liveUserRow.style.display = "block";
                liveUserTextEl.textContent = currentUserText;
                logEl.scrollTop = logEl.scrollHeight;
              }

              // ========== å¿œç­”ã®å®Œäº†ã‚¤ãƒ™ãƒ³ãƒˆã§ç¢ºå®šä¿å­˜ ==========
              const isDone =
                e.type === "response.completed" ||     // æ±ç”¨
                e.type === "response.text.done" ||     // textç³»
                e.type === "response.output_text.done" || // æ–°textç³»
                e.type === "response.audio_transcript.done" // éŸ³å£°æ–‡å­—èµ·ã“ã—ã®å®Œäº†
              ;

              if (isDone) {
                const text = currentAssistantText.trim();
                if (text) addMessage("assistant", text);
                currentAssistantText = "";

                // ãƒ©ã‚¤ãƒ–è¡Œï¼ˆã‚¢ã‚·ã‚¹ã‚¿ãƒ³ãƒˆï¼‰ã¯éè¡¨ç¤ºã®ã¾ã¾
                liveTextEl.textContent = "";
                liveRow.style.display = "none";
              }

              // ========== ãƒ¦ãƒ¼ã‚¶ãƒ¼å´ã®å®Œäº†ã§ç¢ºå®šä¿å­˜ ==========
              const userDone =
                e.type === "conversation.item.input_audio_transcription.completed" ||
                e.type === "input_audio_buffer.transcript.completed" ||
                e.type === "input_audio_buffer.transcript.done";

              if (userDone) {
                const finalUserText = (e?.transcript?.text || currentUserText || "").trim();
                if (finalUserText) addMessage("user", finalUserText);
                currentUserText = "";
                // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ©ã‚¤ãƒ–è¡Œãƒªã‚»ãƒƒãƒˆ
                liveUserTextEl.textContent = "";
                liveUserRow.style.display = "none";
              }

              // ï¼ˆå¿…è¦ãªã‚‰ä»–ã‚¤ãƒ™ãƒ³ãƒˆã‚‚ã“ã“ã§æ‹¾ã†ï¼‰

            } catch {
              // éJSONã¯ç„¡è¦–
            }
          };
        };

        // ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆå´ã§ãƒ‡ãƒ¼ã‚¿ãƒãƒ£ãƒãƒ«ã‚’ä½œæˆ
        attachDataChannel(pc.createDataChannel("oai-events"));
        // ã‚µãƒ¼ãƒå´ã§ä½œã‚‰ã‚ŒãŸå ´åˆã«ã‚‚æ‹¾ã†
        pc.ondatachannel = (ev) => {
          if (!dc || dc.readyState === "closed") attachDataChannel(ev.channel);
        };

        pc.oniceconnectionstatechange = () => {
          const s = pc.iceConnectionState;
          iceEl.textContent = `ICE: ${s}`;
          if (s === "failed" || s === "disconnected") {
            // çŠ¶æ…‹ãŒæ‚ªåŒ–ã—ãŸã‚‰åœæ­¢ï¼ˆå¿…è¦ã«å¿œã˜ã¦è‡ªå‹•ãƒªãƒˆãƒ©ã‚¤ã‚‚å¯ï¼‰
            // stopSession(true);
          }
        };

        // 6) SDPäº¤æ›
        const offer = await pc.createOffer({ offerToReceiveAudio: true });
        await pc.setLocalDescription(offer);

        const sdpUrl = "https://api.openai.com/v1/realtime?model=gpt-4o-realtime-preview";
        const resp = await fetch(sdpUrl, {
          method: "POST",
          headers: {
            "Authorization": `Bearer ${session.client_secret.value}`,
            "Content-Type": "application/sdp",
            "OpenAI-Beta": "realtime=v1"
          },
          body: offer.sdp
        });
        const answerSdp = await resp.text();
        await pc.setRemoteDescription({ type: "answer", sdp: answerSdp });

        setRunningState(true);
      } catch (err) {
        console.error(err);
        setStatus("Failed to start: " + (err?.message || err));
        await stopSession(true); // å¤±æ•—æ™‚ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
      } finally {
        btn.disabled = false;
      }
    }

    async function stopSession(silent = false) {
      if (cleaning) return;
      cleaning = true;
      try {
        // DataChannel
        try { if (dc && dc.readyState !== "closed") dc.close(); } catch {}
        dc = null;

        // PC
        if (pc) {
          try { pc.getSenders().forEach(s => { try { s.track.stop(); } catch {} }); } catch {}
          try { pc.close(); } catch {}
        }
        pc = null;

        // mic
        if (micStream) {
          try { micStream.getTracks().forEach(t => t.stop()); } catch {}
        }
        micStream = null;

        // audio
        if (remoteAudio) {
          try { remoteAudio.pause(); } catch {}
          try { remoteAudio.srcObject = null; } catch {}
          try { remoteAudio.remove(); } catch {}
        }
        remoteAudio = null;

        // ãƒ©ã‚¤ãƒ–è¡Œãƒªã‚»ãƒƒãƒˆ
        currentAssistantText = "";
        liveTextEl.textContent = "";
        liveRow.style.display = "none";
        // è¿½åŠ ï¼šãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ©ã‚¤ãƒ–è¡Œã‚‚ãƒªã‚»ãƒƒãƒˆ
        liveUserTextEl.textContent = "";
        liveUserRow.style.display = "none";

        if (!silent) addMessage("event", "Session stopped");
      } finally {
        setRunningState(false);
        cleaning = false;
      }
    }

    // ========= ã‚¤ãƒ™ãƒ³ãƒˆ =========
    btn.addEventListener("click", async () => {
      if (running) { btn.disabled = true; await stopSession(); btn.disabled = false; }
      else { await startSession(); }
    });

    btnClear.addEventListener("click", () => {
      if (confirm("ãƒ­ã‚°ã‚’æ¶ˆå»ã—ã¾ã™ã‹ï¼Ÿ")) clearLog();
    });

    btnExport.addEventListener("click", () => {
      const blob = new Blob([JSON.stringify({ conversation }, null, 2)], { type: "application/json" });
      const a = document.createElement("a");
      const ts = new Date().toISOString().replace(/[:.]/g, "");
      a.href = URL.createObjectURL(blob);
      a.download = `conversation-${ts}.json`;
      a.click();
      URL.revokeObjectURL(a.href);
    });

    window.addEventListener("beforeunload", () => {
      if (running) {
        try { if (dc && dc.readyState !== "closed") dc.close(); } catch {}
        try { if (pc) pc.close(); } catch {}
        try { if (micStream) micStream.getTracks().forEach(t => t.stop()); } catch {}
      }
    });
  </script>
</body>
</html>
